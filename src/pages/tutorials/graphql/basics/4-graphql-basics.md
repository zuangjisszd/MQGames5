---
title: GraphQL Basics
---

### The Schema Definition Language (SDL)

GraphQL has its own type system that's used to define the _schema_ of an API. The syntax for writing schemas is called _Schema Definition Language_ (SDL).

Here is an example how we can use the SDL to define a simple type called `User`:

```graphql
type User {
  name: String!
  age: Int!
}
```

This type has two _fields_, they're called `name` and `age` and are both of type `String`. The `!` following the type means that this field is _required_.

It's also possible to express relationships between types. In the example of a _blogging_ application, a `User` could be associated with a `Post`:

```graphql
type Post {
  title: String!
  author: User!
}
```

Conversely, the other end of the relationship needs to be placed on the `User` type:

```graphql
type User {
  ...
  posts: [Post!]!
}
```

Note that we just created a _one-to-many_-relationship between `User` and `Post` since the `posts` field on `User` is actually an _array_ of posts.

### Fetching Data with Queries

When working with REST APIs, data is loaded from specific endpoints. Each endpoint has a clearly defined structure of the information that it returns.

The approach that's taken in GraphQL is radically different. Instead of having multiple endpoints that return fix data structures, GraphQL APIs typically only expose _a single endpoint_. This works because the structure of the data that's returned is not fixed. Instead, it's completely flexible and let's the client decide what data is actually needed.

This means that the client needs to send more _information_ to the server to express its data needs - this information is called a _query_.

Let's take a look at an example query that a client could send to a server:

```graphql
{
  allUsers {
    name
  }
}
```

This query would return a list of all users currently stored in the database. Here's an example response:

```js
[
  { 
    "name": "John"
  },
  {
    "name": "Sarah"
  },
  ...
]
```

Notice that each user only has the `name` in the response, but the `age` is not returned by the server. That's because the `name` was the only field that was specified in the query.

If the client also needed the users' `age`, all it has to do is to slightly adjust the query and include the new field in the query's payload:

```grahpql
{
  allUsers {
    name
    age
  }
}
```

One of the major advantages of GraphQL is that it allows for naturally querying _nested_ information. For example, if you wanted to load all the `posts` that a `User` has written, you could simply follow the structure of your types to request this information:

```graphql
{
  allUsers {
    name
    age
    posts {
      title
    }
  }
}
``` 


### Writing Data with Mutations

Next to requesting information from a server, the majority of applications also need some way of making changes to the data that's currently stored in the backend. With GraphQL, these changes are made using so-called _mutations_. There generally are three kinds of mutations:

- creating new data
- updating existing data
- deleting existing data

Mutations follow the same syntactical structure as queries, but they always need to start with the `mutation` keyword. Here's an example for how we might create a new `User`:

```graphql
mutation {
  createUser(name: "Alice", age: 36) {
    name
    age
  }
}
```

Notice that similar to the query we wrote before, we're able to specify a payload where we can ask for differen properties of the new `User`. In our case, we're asking for the `name` and the `age` - though admittedly that's not super helpful in our example since we already know them.

However, being able to also query information when sending mutations can be a very powerful tool that allows to retrieve new information in a single roundtrip! 

One pattern you'll often find is that GraphQL types have _IDs_ that are generated by the server. Extending our `User` type from the before, we could add an `id` as follows:

```graphql
type User {
  id: ID!
  ...
}
``` 

Now, when a new `User` is created, you could directly ask for the `id` since that is information that wasn't available on the client beforehand:

```graphql
mutation {
  createUser(name: "Alice", age: 36) {
    id
  }
}
```


### Realtime Updates with Subscriptions

Another important requirement for many applications today is to have a _realtime_ connection to the server in order to get immediately informed about important events. For this use case, GraphQL offers the concept of _subscriptions_.  

When a client _subscribes_ to an event, it will hold a steady connection to the server. Whenever that particular event then actually happens, the server pushes the corresponding data to the client. Unlike queries and mutations that follow a typical "_request-response_-cycle", subscriptions represent a _stream_ of data sent over to the client.

Subscriptions are written using the same syntax as queries and mutations. Here's an example where we subscribe on events happening on the `User` type:

```graphql
subscription {
  newUser {
    name
    age
  }
}
```

After a client sent this subscription to a server, a connection is openend between them. Then, whevenever a new mutation is performed that creates a new `User`, the server sends the information about this user over to the client:

```js
{
  "name": "Jane",
  "age": 23
}
```


### Defining A Schema

Now that you have a rough idea of what queries, mutations and subscriptions look like, let's put it all together with how you can write a schema that would allow to execute the examples you've seen so far.

The _schema_ is one of the most important concepts when working with a GraphQL API. It specifies the capabilities of the API and defines how clients can request the data. It is often seen as a _contract_ between the server and client.

Generally, a schema is simply a collection of GraphQL types. However, when writing the schema for an API, there are some special _root_ types:

```graphql
type Query {
}

type Mutation {
}

type Subscription {
}
```

The `Query`, `Mutation` and `Subscription` types are the _entry points_ for the requests sent by the client. To enable the `allUsers`-query that we save before, the `Query` would have to be written as follows:

```graphql
type Query {
  allUsers: [User!]!
}
```

`allUsers` is called a _root field_ of the API. Similarly, for the `createUser`-mutation, we'd have to add a root field to the `Mutation` type:

```graphql
type Mutation {
  createUser(name: String!, age: String!): User!
}
```

Finally, for the subscriptions, we'd have to add the `newUser` root field:

```graphql
type Subscription {
  newUser: User!
}
```

